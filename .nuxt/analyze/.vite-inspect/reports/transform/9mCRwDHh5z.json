{
  "resolvedId": "/Users/bensonmboci/Desktop/project/portfolio/portfolio/node_modules/@apollo/client/utilities/graphql/transform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from \"graphql\";\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition, } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n    kind: Kind.FIELD,\n    name: {\n        kind: Kind.NAME,\n        value: \"__typename\",\n    },\n};\nfunction isEmpty(op, fragmentMap) {\n    return (!op ||\n        op.selectionSet.selections.every(function (selection) {\n            return selection.kind === Kind.FRAGMENT_SPREAD &&\n                isEmpty(fragmentMap[selection.name.value], fragmentMap);\n        }));\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))\n        ? null\n        : doc;\n}\nfunction getDirectiveMatcher(configs) {\n    var names = new Map();\n    var tests = new Map();\n    configs.forEach(function (directive) {\n        if (directive) {\n            if (directive.name) {\n                names.set(directive.name, directive);\n            }\n            else if (directive.test) {\n                tests.set(directive.test, directive);\n            }\n        }\n    });\n    return function (directive) {\n        var config = names.get(directive.name.value);\n        if (!config && tests.size) {\n            tests.forEach(function (testConfig, test) {\n                if (test(directive)) {\n                    config = testConfig;\n                }\n            });\n        }\n        return config;\n    };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n    var map = new Map();\n    return function inUseGetterFunction(key) {\n        if (key === void 0) { key = defaultKey; }\n        var inUse = map.get(key);\n        if (!inUse) {\n            map.set(key, (inUse = {\n                variables: new Set(),\n                fragmentSpreads: new Set(),\n            }));\n        }\n        return inUse;\n    };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n    checkDocument(doc);\n    var getInUseByOperationName = makeInUseGetterFunction(\"\");\n    var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n    var getInUse = function (ancestors) {\n        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n            if (isArray(ancestor))\n                continue;\n            if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\n            }\n            if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n                return getInUseByFragmentName(ancestor.name.value);\n            }\n        }\n        globalThis.__DEV__ !== false && invariant.error(82);\n        return null;\n    };\n    var operationCount = 0;\n    for (var i = doc.definitions.length - 1; i >= 0; --i) {\n        if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n            ++operationCount;\n        }\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var shouldRemoveField = function (nodeDirectives) {\n        return isNonEmptyArray(nodeDirectives) &&\n            nodeDirectives\n                .map(directiveMatcher)\n                .some(function (config) { return config && config.remove; });\n    };\n    var originalFragmentDefsByPath = new Map();\n    var firstVisitMadeChanges = false;\n    var fieldOrInlineFragmentVisitor = {\n        enter: function (node) {\n            if (shouldRemoveField(node.directives)) {\n                firstVisitMadeChanges = true;\n                return null;\n            }\n        },\n    };\n    var docWithoutDirectiveSubtrees = visit(doc, {\n        Field: fieldOrInlineFragmentVisitor,\n        InlineFragment: fieldOrInlineFragmentVisitor,\n        VariableDefinition: {\n            enter: function () {\n                return false;\n            },\n        },\n        Variable: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.variables.add(node.name.value);\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                if (shouldRemoveField(node.directives)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.fragmentSpreads.add(node.name.value);\n                }\n            },\n        },\n        FragmentDefinition: {\n            enter: function (node, _key, _parent, path) {\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\n            },\n            leave: function (node, _key, _parent, path) {\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n                if (node === originalNode) {\n                    return node;\n                }\n                if (operationCount > 0 &&\n                    node.selectionSet.selections.every(function (selection) {\n                        return selection.kind === Kind.FIELD &&\n                            selection.name.value === \"__typename\";\n                    })) {\n                    getInUseByFragmentName(node.name.value).removed = true;\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n        Directive: {\n            leave: function (node) {\n                if (directiveMatcher(node)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n    });\n    if (!firstVisitMadeChanges) {\n        return doc;\n    }\n    var populateTransitiveVars = function (inUse) {\n        if (!inUse.transitiveVars) {\n            inUse.transitiveVars = new Set(inUse.variables);\n            if (!inUse.removed) {\n                inUse.fragmentSpreads.forEach(function (childFragmentName) {\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n                        inUse.transitiveVars.add(varName);\n                    });\n                });\n            }\n        }\n        return inUse;\n    };\n    var allFragmentNamesUsed = new Set();\n    docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n        if (def.kind === Kind.OPERATION_DEFINITION) {\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n                allFragmentNamesUsed.add(childFragmentName);\n            });\n        }\n        else if (def.kind === Kind.FRAGMENT_DEFINITION &&\n            operationCount === 0 &&\n            !getInUseByFragmentName(def.name.value).removed) {\n            allFragmentNamesUsed.add(def.name.value);\n        }\n    });\n    allFragmentNamesUsed.forEach(function (fragmentName) {\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n            allFragmentNamesUsed.add(childFragmentName);\n        });\n    });\n    var fragmentWillBeRemoved = function (fragmentName) {\n        return !!((!allFragmentNamesUsed.has(fragmentName) ||\n            getInUseByFragmentName(fragmentName).removed));\n    };\n    var enterVisitor = {\n        enter: function (node) {\n            if (fragmentWillBeRemoved(node.name.value)) {\n                return null;\n            }\n        },\n    };\n    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n        FragmentSpread: enterVisitor,\n        FragmentDefinition: enterVisitor,\n        OperationDefinition: {\n            leave: function (node) {\n                if (node.variableDefinitions) {\n                    var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\n                        return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                                return usedVariableNames_1.has(varDef.variable.name.value);\n                            }) });\n                    }\n                }\n            },\n        },\n    }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n    return visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                if (parent &&\n                    parent.kind ===\n                        Kind.OPERATION_DEFINITION) {\n                    return;\n                }\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === \"__typename\" ||\n                            selection.name.value.lastIndexOf(\"__\", 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === \"export\"; })) {\n                    return;\n                }\n                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n            },\n        },\n    });\n}, {\n    added: function (field) {\n        return field === TYPENAME_FIELD;\n    },\n});\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === \"connection\";\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === \"key\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(83);\n            }\n        }\n        return willRemove;\n    },\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (!!selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!isField(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === Kind.VARIABLE &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions\n                        ? node.variableDefinitions.filter(function (varDef) {\n                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                        })\n                        : [] });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\nexport function buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === \"query\") {\n        return document;\n    }\n    var modifiedDoc = visit(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { operation: \"query\" });\n            },\n        },\n    });\n    return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === \"client\"; },\n            remove: true,\n        },\n    ], document);\n    return modifiedDoc;\n}\n//# sourceMappingURL=transform.js.map",
      "start": 1700234742348,
      "end": 1700234742450,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1700234742450,
      "end": 1700234742450,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1700234742451,
      "end": 1700234742451,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1700234742451,
      "end": 1700234742451,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1700234742451,
      "end": 1700234742451,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1700234742451,
      "end": 1700234742451,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1700234742451,
      "end": 1700234742451,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1700234742451,
      "end": 1700234742452,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1700234742452,
      "end": 1700234742452,
      "order": "normal"
    }
  ]
}
